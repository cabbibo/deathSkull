#pragma kernel CSMain
 
#define threadX 8
#define threadY 8
#define threadZ 8

int _StrideX;
int _StrideY;
int _StrideZ;

#define gridX (threadX * _StrideX)
#define gridY (threadY * _StrideY)
#define gridZ (threadZ * _StrideZ)

float _DeltaTime;
float _Time;
int _Reset;
int _VertsPerHair;


float3 _Hand;
float3 _Vel;
float3 _EndPos;
float _PullVal;

struct Vert{
	float3 pos;
	float3 oPos;
	float3 ogPos;
	float3 vel;
	float3 norm;
	float2 uv;
	float3 debug;
};

struct Head{

  float4x4 localToWorld;
  float4x4 worldToLocal;
  float3 pos;
  float3 debug;

};

struct Hand{

  float4x4 localToWorld;
  float4x4 worldToLocal;
  float3 pos;
  float3 vel;
  float trigger;
  float3 debug;

};


struct Human{

  Head head;
  Hand hand1;
  Hand hand2;

};

int _NumberHumans;


RWStructuredBuffer<float4x4> transformMatrix;
RWStructuredBuffer<Vert> vertBuffer;
RWStructuredBuffer<Human> humanBuffer;

#include "Chunks/snoise.cginc"
#include "Chunks/curlNoise.cginc"

#include "Chunks/noise.cginc"

float3 getVel( float3 p1 , float3 p2 ){

	float3 v = p1 - p2;

	if( length( v ) > .5){ v = normalize( v ) *.5; }
	return v;
}


[numthreads(threadX,threadY,threadZ)]
void CSMain (uint3 id : SV_DispatchThreadID) {
  
  int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  Vert vert = vertBuffer[ pID ];

  if( _Reset == 1 ){

    float3 tPos = mul( transformMatrix[0] , float4( vert.ogPos , 1)).xyz; 
    vert.oPos = tPos;
    vert.pos = tPos;
  }else{


  //vert.debug = float3( 1,1,1);
	float3 tNorm = mul( transformMatrix[0] , float4( vert.norm , 0)).xyz;
  	float g = 5.1;//10.9;


  	float3 force = normalize((normalize( tNorm ) + float3(0,4,0))) * g;// * (.4 + _PullVal * .7) ;// * ( 1-vert.uv.x);//float3( 0 , g , 0 );
    //force += float3( 0 , -3, 0) * _PullVal;

    force += 3 * float3(0,0,1) *snoise( vert.pos * 1 + _Time * .3 );

  	if( vert.uv.x == 0 ){ 
  		float3 tPos = mul( transformMatrix[0] , float4( vert.ogPos , 1)).xyz; 
  		vert.pos = tPos; 
  		vert.oPos = tPos;
  		//vert.debug = float3( .2,.6,1);
  	}

  	/*if( vert.uv.x == (float(_VertsPerHair-1)/float(_VertsPerHair)) ){ 
  		//float3 tPos = mul( transformMatrix[0] , float4( vert.ogPos , 1)).xyz; 
  		float3 tPos=  (_EndPos - vert.pos)* .1 * (1.4 * hash( vert.debug.z) + .4) + vert.pos;//.1 * float3( hash( vert.debug.z) ,hash( vert.debug.z * 20),hash( vert.debug.z*10)) ;
  		vert.pos = lerp( vert.pos , tPos , _PullVal); 
  		vert.oPos = lerp( vert.oPos , tPos , _PullVal);
  		//vert.debug = float3( 1,.6,.2);
  	}*/


  	for( int i = 0; i < _NumberHumans; i++){

      Human h = humanBuffer[i];


      float3 head = h.head.pos;
      float3 hand1 = h.hand1.pos;
      float3 hand2 = h.hand2.pos;
      float3 dif;
      dif = hand1 - vert.pos;

      float3 humanForce = float3(0,0,0);

      if( length( dif )<.1){
        humanForce -= normalize( dif ) * (1-2 * h.hand1.trigger);
      }

      dif = hand2 - vert.pos;

      if( length( dif )<.1){
        humanForce -= normalize( dif )* (1-2 * h.hand2.trigger);
      }

      dif = head - vert.pos;

      if( length( dif )<1){
        humanForce -= .4 * normalize( dif );

      }

      force += humanForce * 100;


    }

    //force += 2.1 * float3( 1 , 0 , 0 )* noise( vert.pos * 20 + float3( _Time * 10 , 0 , 0));
  // Inertia: objects in motion stay in motion.
  	float3 vel = getVel( vert.pos , vert.oPos -_Vel * .05 );

  	float3 acceleration = force;

    float dampening = .99 - (1-_PullVal) * .1;// - vert.life * .01;
  	float3 next = vert.pos + vel * dampening   + acceleration * _DeltaTime * _DeltaTime;

  	vert.oPos = vert.pos;
  	vert.pos = next;
  	vert.vel = vel;

    

  	

  }


	vertBuffer[pID] = vert;
	
}