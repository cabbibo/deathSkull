
#pragma kernel CSMain
 
#define threadX 4
#define threadY 4
#define threadZ 4

int _StrideX;
int _StrideY;
int _StrideZ;

#define gridX (threadX * _StrideX)
#define gridY (threadY * _StrideY)
#define gridZ (threadZ * _StrideZ)

float _DeltaTime;
float _Time;
int _Reset;
int _VertsPerHair;


float3 _Hand;
float3 _Vel;
float3 _EndPos;

struct Vert{
  float3 pos;
  float3 oPos;
  float3 ogPos;
  float3 vel;
  float3 norm;
  float2 uv;
  float3 debug;
};

struct Head{

  float4x4 localToWorld;
  float4x4 worldToLocal;
  float3 pos;
  float3 debug;

};

struct Hand{

  float4x4 localToWorld;
  float4x4 worldToLocal;
  float3 pos;
  float3 vel;
  float trigger;
  float3 debug;

};


struct Human{

  Head head;
  Hand hand1;
  Hand hand2;

};

int _NumberHumans;


RWStructuredBuffer<float4x4> transformMatrix;
RWStructuredBuffer<Vert> vertBuffer;
RWStructuredBuffer<Human> humanBuffer;

#include "Chunks/noise.cginc"

float3 getVel( float3 p1 , float3 p2 ){

  float3 v = p1 - p2;

  if( length( v ) > .5){ v = normalize( v ) *.5; }
  return v;
}


[numthreads(threadX,threadY,threadZ)]
void CSMain (uint3 id : SV_DispatchThreadID) {
  
  int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  Vert vert = vertBuffer[ pID ];

  if( _Reset == 1 ){

    float3 tPos = mul( transformMatrix[0] , float4( vert.ogPos , 1)).xyz; 
    vert.oPos = tPos;
    vert.pos = tPos;
  }else{


  //vert.debug = float3( 1,1,1);
  float3 tNorm = mul( transformMatrix[0] , float4( vert.norm , 0)).xyz;
    float g = 5.1;//10.9;


    float3 force = normalize( tNorm ) * g * 3  * ( 1-vert.uv.x);//float3( 0 , g , 0 );
    force += float3( 0 , -15, 0);
    if( vert.uv.x == 0 ){ 
      float3 tPos = mul( transformMatrix[0] , float4( vert.ogPos , 1)).xyz; 
      vert.pos = tPos; 
      vert.oPos = tPos;
      //vert.debug = float3( .2,.6,1);
    }

    if( vert.uv.x == (float(_VertsPerHair-1)/float(_VertsPerHair)) ){ 
      //float3 tPos = mul( transformMatrix[0] , float4( vert.ogPos , 1)).xyz; 
      float3 tPos=  (_EndPos - vert.pos)*  .1 + vert.pos;//.1 * float3( hash( vert.debug.z) ,hash( vert.debug.z * 20),hash( vert.debug.z*10)) ;
      //vert.pos = tPos; 
      //vert.oPos = tPos;
      //vert.debug = float3( 1,.6,.2);
    }


    for( int i = 0; i < _NumberHumans; i++){

      Human h = humanBuffer[i];


      float3 head = h.head.pos;
      float3 hand1 = h.hand1.pos;
      float3 hand2 = h.hand2.pos;
      float3 dif;
      dif = hand1 - vert.pos;

      float3 humanForce = float3(0,0,0);

      if( length( dif )<.5 + h.hand1.trigger){
        humanForce -= normalize( dif ) * (1-10 * h.hand1.trigger);
      }

      dif = hand2 - vert.pos;

      if( length( dif )<.5+ h.hand2.trigger){
        humanForce -= normalize( dif )* (1-10 * h.hand2.trigger);
      }

      dif = head- vert.pos;

      if( length( dif )<1){
        humanForce -= .4 * normalize( dif );

      }

      force += humanForce * 100;


    }

    //force += 2.1 * float3( 1 , 0 , 0 )* noise( vert.pos * 20 + float3( _Time * 10 , 0 , 0));
  // Inertia: objects in motion stay in motion.
    float3 vel = getVel( vert.pos , vert.oPos -_Vel * .05 );

    float3 acceleration = force;

    float dampening = .9;// - vert.life * .01;
    float3 next = vert.pos + vel * dampening   + acceleration * _DeltaTime * _DeltaTime;

    vert.oPos = vert.pos;
    vert.pos = next;
    vert.vel = vel;

    

    

  }


  vertBuffer[pID] = vert;
  
}